Description: >
    This template deploys a Lambda function that will generate the required config.yaml for 
    RKE to be able to manage the hosts of a working Rancher cluster.

Parameters:

    EnvironmentName:
        Description: An environment name that will be prefixed to resource names
        Type: String

    AutoScalingGroup:
        Description: The AutoScalingGroup that the EC2 cluster is deployed to
        Type: String

    KeyName:
        Description: Name of an existing EC2 KeyPair to enable SSH access to the instances
        Type: String

    InstanceUser:
        Type: String
        Default: 'ec2-user'
        Description: Name of admin user for instance (ec2-user for example)

    FQDN:
        Type: String
        Description: Fully qualified URL for using app.  DNS of FQDN must be pointed to CNAME of ALB.
    
Resources:

  rkeS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join ['-', [!Ref 'EnvironmentName', 'rke']]
      AccessControl: 'BucketOwnerFullControl'
      Tags:
        -
          Key: 'Name'
          Value: !Join ['-', [!Ref 'EnvironmentName', 'S3']]
    DeletionPolicy: Delete

  NotificationTopic:
    Type: 'AWS::SNS::Topic'
    Properties:
      Subscription:
        - Endpoint: !GetAtt 
            - LifecycleGenerateRKE
            - Arn
          Protocol: lambda
    DependsOn: LifecycleGenerateRKE

  InstanceTerminatingHook:
    Type: 'AWS::AutoScaling::LifecycleHook'
    Properties:
      AutoScalingGroupName: !Ref AutoScalingGroup
      DefaultResult: ABANDON
      HeartbeatTimeout: '900'
      LifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING'
      NotificationTargetARN: !Ref NotificationTopic
      RoleARN: !GetAtt 
        - AutoscalingNotificationRole
        - Arn
    DependsOn: NotificationTopic

  InstanceActivatingHook:
    Type: 'AWS::AutoScaling::LifecycleHook'
    Properties:
      AutoScalingGroupName: !Ref AutoScalingGroup
      DefaultResult: CONTINUE
      HeartbeatTimeout: '900'
      LifecycleTransition: 'autoscaling:EC2_INSTANCE_LAUNCHING'
      NotificationTargetARN: !Ref NotificationTopic
      RoleARN: !GetAtt 
        - AutoscalingNotificationRole
        - Arn
    DependsOn: NotificationTopic

  AutoscalingNotificationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - autoscaling.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AutoScalingNotificationAccessRole'

  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      Policies:
        - PolicyName: lambda-inline
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'autoscaling:CompleteLifecycleAction'
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                  - 'ec2:DescribeInstances'
                  - 'ec2:DescribeInstanceAttribute'
                  - 'ec2:DescribeInstanceStatus'
                  - 'ec2:DescribeHosts'
                  - 'ecs:ListContainerInstances'
                  - 'ecs:SubmitContainerStateChange'
                  - 'ecs:SubmitTaskStateChange'
                  - 'ecs:DescribeContainerInstances'
                  - 'ecs:UpdateContainerInstancesState'
                  - 'ecs:ListTasks'
                  - 'ecs:DescribeTasks'
                  - 'sns:Publish'
                  - 'sns:ListSubscriptions'
                Resource: '*'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AutoScalingNotificationAccessRole'

  LambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !Ref LifecycleGenerateRKE
      Action: 'lambda:InvokeFunction'
      Principal: sns.amazonaws.com
      SourceArn: !Ref NotificationTopic

  LifecycleGenerateRKE:
    Type: 'AWS::Lambda::Function'
    Properties:
      Environment:
        Variables:
          CLUSTER: !Ref AutoScalingGroup
          KeyName: !Ref KeyName
          InstanceUser: !Ref InstanceUser
          rkeS3Bucket:  !Ref rkeS3Bucket
      Code:
        ZipFile: !Join 
          - ''
          - - |
              import boto3,json,os,time
              ec2Client = boto3.client('ec2')
              autoscalingClient = boto3.client('autoscaling')
              snsClient = boto3.client('sns')
              lambdaClient = boto3.client('lambda')
              s3Client = boto3.resource("s3")

              def lambda_handler(event, context):
                  instanceUser=os.environ['InstanceUser']
                  keyName=os.environ['KeyName']
                  FQDN=os.environ['FQDN']
                  rkeS3Bucket=os.environ['rkeS3Bucket']
                  snsTopicArn=event['Records'][0]['Sns']['TopicArn']
                  snsMessage=json.loads(event['Records'][0]['Sns']['Message'])

                  lifecycleHookName=snsMessage['LifecycleHookName']
                  lifecycleActionToken=snsMessage['LifecycleActionToken']

                  asgName=snsMessage['AutoScalingGroupName']
                  
                  rkeConfig = generateRKEConfig(asgName,instanceUser,keyName)

                  if rkeConfig:
                      try:
                          encoded_payload = rkeConfig.encode("utf-8")
                          s3Client.Bucket(rkeS3Bucket).put_object(Key=config.yaml, Body=encoded_payload)
                          response = autoscalingClient.complete_lifecycle_action(LifecycleHookName=lifecycleHookName,AutoScalingGroupName=asgName,LifecycleActionToken=lifecycleActionToken,LifecycleActionResult='CONTINUE')
                      except BaseException as e:
                          print(str(e))
                  elif:
                      time.sleep(5)
                      publishSNSMessage(snsMessage,snsTopicArn)
      Handler: index.lambda_handler
      Role: !GetAtt 
        - LambdaExecutionRole
        - Arn
      Runtime: python3.6
      Timeout: 10

  LifecycleTestNodes:
    Type: 'AWS::Lambda::Function'
    Properties:
      Environment:
        Variables:
          CLUSTER: !Ref AutoScalingGroup
          KeyName: !Ref KeyName
          InstanceUser: !Ref InstanceUser
          rkeS3Bucket:  !Ref rkeS3Bucket
      Code:
        ZipFile: !Join 
          - ''
          - - |
              import boto3,json,os,time
              ec2Client = boto3.client('ec2')
              autoscalingClient = boto3.client('autoscaling')
              snsClient = boto3.client('sns')
              lambdaClient = boto3.client('lambda')
              s3Client = boto3.resource("s3")

              def publishSNSMessage(snsMessage,snsTopicArn):
                  response = snsClient.publish(TopicArn=snsTopicArn,Message=json.dumps(snsMessage),Subject='Rebalancing')

              def checkEc2s(asgName):
                  filters = [{  
                  'Name': 'tag:aws:autoscaling:groupName',
                  'Values': [asgName]
                  }]
                  ec2ContainerInstances = ec2Client.describe_instances(Filters=filters)
                  print(str(ec2ContainerInstances))
                  pendingEc2s = 0
                  activeEc2s = 0
                  for i in range(len(ec2ContainerInstances['Reservations'])):
                      instance = ec2ContainerInstances['Reservations'][i]['Instances'][0]
                      print(str(instance['State']['Name']))
                      print(str(instance))
                      if instance['State']['Name'] == 'disabling':
                          pendingEc2s = pendingEc2s + 1
                      elif instance['State']['Name'] == 'pending':
                          pendingEc2s = pendingEc2s + 1
                      elif instance['State']['Name'] == 'running':
                          activeEc2s = activeEc2s + 1
                  print("Active EC2s: ",activeEc2s)
                  return pendingEc2s

              def lambda_handler(event, context):
                  instanceUser=os.environ['InstanceUser']
                  keyName=os.environ['KeyName']
                  FQDN=os.environ['FQDN']
                  rkeS3Bucket=os.environ['rkeS3Bucket']
                  snsTopicArn=event['Records'][0]['Sns']['TopicArn']
                  snsMessage=json.loads(event['Records'][0]['Sns']['Message'])
                  lifecycleHookName=snsMessage['LifecycleHookName']
                  lifecycleActionToken=snsMessage['LifecycleActionToken']
                  asgName=snsMessage['AutoScalingGroupName']
                  pendingEc2s=checkEc2s(asgName);
                  if pendingEc2s==0:
                      try:
                          response = autoscalingClient.complete_lifecycle_action(LifecycleHookName=lifecycleHookName,AutoScalingGroupName=asgName,LifecycleActionToken=lifecycleActionToken,LifecycleActionResult='CONTINUE')
                      except BaseException as e:
                          print(str(e))
                  elif pendingEc2s>=1:
                      time.sleep(5)
                      publishSNSMessage(snsMessage,snsTopicArn)
      Handler: index.lambda_handler
      Role: !GetAtt 
        - LambdaExecutionRole
        - Arn
      Runtime: python3.6
      Timeout: 10